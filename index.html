<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏÜêÎÅùÏúºÎ°ú Ìå°! AI ÌíçÏÑ† ÌÑ∞Îú®Î¶¨Í∏∞</title>
    <!-- Pretendard Font -->
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f2f5;
            flex-direction: column;
        }
        h1 {
            font-size: 3.5em;
            font-weight: 800;
            margin-bottom: 15px;
            color: #000;
        }
        .container {
            position: relative;
            width: 1280px;
            height: 720px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }
        #webcam, #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 20px;
        }
        #webcam {
            transform: scaleX(-1);
            display: none;
        }
        #output_canvas {
            z-index: 10;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            font-weight: 600;
            color: #555;
            z-index: 11;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 15px;
            color: #8d99ae;
            border-top: 1px solid #e5e5e5;
            width: 1280px;
        }
        footer p {
            margin: 4px 0;
        }
        footer .font-bold {
            font-weight: 700;
            color: #2b2d42;
        }
        footer a {
            text-decoration: none;
            color: #219ebc;
            font-weight: 600;
        }
        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>ÏÜêÎÅùÏúºÎ°ú Ìå°! AI ÌíçÏÑ† ÌÑ∞Îú®Î¶¨Í∏∞ üéàüëÜ</h1>
    <div class="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas" width="1280" height="720"></canvas>
        <div id="loading">AI Î™®Îç∏ÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...</div>
    </div>
    <footer>
          <p class="font-bold">Made by <a href="https://litt.ly/dot_connector" target="_blank" rel="noopener noreferrer">ÍπÄÏßÑÍ¥Ä (Îã∑Ïª§ÎÑ•ÌÑ∞)</a></p>
          <p>Î∞∞ÏõÄ, ÎÇòÎàî, ÏÑ±Ïû•ÏùÑ Ï∂îÍµ¨ÌïòÎäî Ïó∞Í≤∞Ï£ºÏùòÏûê</p>
    </footer>

    <script type="module">
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');

        let gameState = 'loading'; // loading, ready, playing, roundOver, gameOver
        
        // Game structure variables
        let round = 1;
        const maxRounds = 3;
        const winScore = 2; // Best of 3
        let p1RoundWins = 0, p2RoundWins = 0;
        let p1CurrentScore = 0, p2CurrentScore = 0;
        let roundWinner = null, finalWinner = null;

        const GAME_DURATION = 30; // 30 seconds per round
        let timeLeft = GAME_DURATION;
        let gameTimer = null;
        let balloonSpawnTimer = null;
        
        const p1Color = '#023047';
        const p2Color = '#d00000';

        let balloons = [];
        const clickCooldown = 200; // ms
        let p1LastClickTime = 0, p2LastClickTime = 0;

        class Balloon {
            constructor(player) {
                this.player = player;
                this.radius = Math.random() * 20 + 30; // 30-50px radius
                const playerZoneWidth = canvasElement.width / 2 - this.radius * 2;
                this.x = (this.player === 1) 
                    ? Math.random() * playerZoneWidth + this.radius
                    : Math.random() * playerZoneWidth + this.radius + canvasElement.width / 2;
                this.y = canvasElement.height + this.radius;
                this.color = this.player === 1 ? p1Color : p2Color;
                this.velocity = -(Math.random() * 1.5 + 1); // Upward speed
            }

            update() {
                this.y += this.velocity;
            }

            draw() {
                // Balloon body
                canvasCtx.fillStyle = this.color;
                canvasCtx.beginPath();
                canvasCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                canvasCtx.fill();

                // Balloon shine
                canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                canvasCtx.beginPath();
                canvasCtx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.4, this.radius * 0.5, 0, Math.PI * 2);
                canvasCtx.fill();

                // Balloon knot
                canvasCtx.beginPath();
                canvasCtx.moveTo(this.x - this.radius * 0.2, this.y + this.radius);
                canvasCtx.lineTo(this.x + this.radius * 0.2, this.y + this.radius);
                canvasCtx.lineTo(this.x, this.y + this.radius * 1.3);
                canvasCtx.closePath();
                canvasCtx.fillStyle = this.color;
                canvasCtx.fill();
            }
        }

        function spawnBalloon() {
            const player = Math.random() < 0.5 ? 1 : 2;
            balloons.push(new Balloon(player));
        }
        
        function drawGameUI() {
            balloons.forEach((balloon, index) => {
                balloon.update();
                balloon.draw();
                if (balloon.y < -balloon.radius) {
                    balloons.splice(index, 1);
                }
            });
            drawBottomBar();
        }
        
        function drawBottomBar() {
            canvasCtx.fillStyle = "rgba(255, 255, 255, 0.8)";
            canvasCtx.fillRect(0, 650, 1280, 70);

            canvasCtx.font = "bold 24px 'Pretendard'";
            canvasCtx.textAlign = "center";
            canvasCtx.textBaseline = "middle";
            
            canvasCtx.fillStyle = p1Color;
            canvasCtx.fillText(`[ ${'‚òÖ'.repeat(p1RoundWins)}${'‚òÜ'.repeat(winScore-p1RoundWins)} ]  1P Ï†êÏàò: ${p1CurrentScore}`, 200, 685);
            
            canvasCtx.fillStyle = "#343a40";
            canvasCtx.font = "bold 36px 'Pretendard'";
            canvasCtx.fillText(`${round} ÎùºÏö¥Îìú | ${timeLeft}Ï¥à`, 640, 685);
            
            canvasCtx.fillStyle = p2Color;
            canvasCtx.font = "bold 24px 'Pretendard'";
            canvasCtx.fillText(`2P Ï†êÏàò: ${p2CurrentScore}  [ ${'‚òÖ'.repeat(p2RoundWins)}${'‚òÜ'.repeat(winScore-p2RoundWins)} ]`, 1080, 685);
        }

        function handleHandInteraction(hand, playerNum) {
            const indexTip = hand[8];
            const middleTip = hand[12];
            
            const ix = (1 - indexTip.x) * canvasElement.width;
            const iy = indexTip.y * canvasElement.height;
            const pointerColor = playerNum === 1 ? 'rgba(2, 48, 71, 0.7)' : 'rgba(208, 0, 0, 0.7)';
            
            canvasCtx.beginPath();
            canvasCtx.arc(ix, iy, 15, 0, 2 * Math.PI);
            canvasCtx.fillStyle = pointerColor;
            canvasCtx.fill();

            const distance = Math.hypot(((1-indexTip.x) - (1-middleTip.x)) * canvasElement.width, (indexTip.y - middleTip.y) * canvasElement.height);
            let isClicking = distance < 35;
            let now = Date.now();
            let lastClickTime = playerNum === 1 ? p1LastClickTime : p2LastClickTime;
            
            if (isClicking && now > lastClickTime + clickCooldown) {
                if (playerNum === 1) p1LastClickTime = now; else p2LastClickTime = now;
                
                for (let i = balloons.length - 1; i >= 0; i--) {
                    const balloon = balloons[i];
                    if (balloon.player === playerNum) {
                        const distToBalloon = Math.hypot(ix - balloon.x, iy - balloon.y);
                        if (distToBalloon < balloon.radius) {
                            balloons.splice(i, 1);
                            if (playerNum === 1) p1CurrentScore++; else p2CurrentScore++;
                            break; 
                        }
                    }
                }
            }
        }
        
        function startRound() {
            gameState = 'playing';
            timeLeft = GAME_DURATION;
            p1CurrentScore = 0;
            p2CurrentScore = 0;
            balloons = [];

            gameTimer = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    endRound();
                }
            }, 1000);
            
            balloonSpawnTimer = setInterval(spawnBalloon, 400);
        }
        
        function endRound() {
            clearInterval(gameTimer);
            clearInterval(balloonSpawnTimer);
            if (p1CurrentScore > p2CurrentScore) {
                p1RoundWins++;
                roundWinner = 1;
            } else if (p2CurrentScore > p1CurrentScore) {
                p2RoundWins++;
                roundWinner = 2;
            } else {
                roundWinner = 'DRAW';
            }
            gameState = 'roundOver';
            setTimeout(nextRound, 3000);
        }

        function nextRound() {
            if (p1RoundWins === winScore || p2RoundWins === winScore || round >= maxRounds) {
                finalWinner = p1RoundWins > p2RoundWins ? 1 : (p2RoundWins > p1RoundWins ? 2 : 'DRAW');
                gameState = 'gameOver';
            } else {
                round++;
                roundWinner = null;
                startRound();
            }
        }

        function resetGame() {
            round = 1;
            p1RoundWins = 0;
            p2RoundWins = 0;
            p1CurrentScore = 0;
            p2CurrentScore = 0;
            balloons = [];
            timeLeft = GAME_DURATION;
            roundWinner = null;
            finalWinner = null;
            gameState = 'ready';
        }

        function drawOverlay() {
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.textAlign = 'center';
            canvasCtx.fillStyle = 'white';
            const baseFont = "'Pretendard', sans-serif";

            if (gameState === 'gameOver' || gameState === 'roundOver') {
                const title = gameState === 'roundOver' ? `${round} ÎùºÏö¥Îìú Ï¢ÖÎ£å` : 'ÏµúÏ¢Ö Í≤∞Í≥º!';
                const winner = gameState === 'roundOver' ? roundWinner : finalWinner;
                
                canvasCtx.font = `bold 80px ${baseFont}`;
                canvasCtx.fillStyle = "#FFC300";
                canvasCtx.fillText(title, 640, 280);
                
                let winnerText, winnerColor;
                if(winner === 'DRAW'){
                    winnerText = 'Î¨¥ÏäπÎ∂Ä!';
                    winnerColor = 'white';
                } else {
                    winnerText = `ÌîåÎ†àÏù¥Ïñ¥ ${winner} ÏäπÎ¶¨!`;
                    winnerColor = winner === 1 ? '#8ECAE6' : '#FFB4A2'; // Softer colors for text
                }
                canvasCtx.font = `800 120px ${baseFont}`;
                canvasCtx.fillStyle = winnerColor;
                canvasCtx.fillText(winnerText, 640, 450);
                
                if (gameState === 'gameOver') {
                    canvasCtx.font = `50px ${baseFont}`;
                    canvasCtx.fillStyle = 'white';
                    canvasCtx.fillText("Îã§Ïãú ÏãúÏûëÌïòÎ†§Î©¥ ÏñëÏÜêÏùÑ Î™®Îëê Îì§Ïñ¥Ï£ºÏÑ∏Ïöî!", 640, 600);
                }
            } else if (gameState === 'ready') {
                canvasCtx.font = `800 80px ${baseFont}`;
                canvasCtx.fillText("ÏÜêÎÅùÏúºÎ°ú Ìå°! AI ÌíçÏÑ† ÌÑ∞Îú®Î¶¨Í∏∞", 640, 280);
                canvasCtx.font = `50px ${baseFont}`;
                canvasCtx.fillText("ÏñëÏÜêÏùÑ ÌôîÎ©¥Ïóê Î≥¥Ïó¨Ï£ºÎ©¥ Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§.", 640, 380);
                canvasCtx.font = `40px ${baseFont}`;
                canvasCtx.fillText("ÏûêÏã†Ïùò ÏÉâÍπîÏóê ÎßûÎäî ÌíçÏÑ†ÏùÑ ÌÑ∞Îú®Î¶¨ÏÑ∏Ïöî!", 640, 450);
            }
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-canvasElement.width, 0);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();
            
            canvasCtx.fillStyle = "rgba(255, 255, 255, 0.6)";
            canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            
            const hands = results.multiHandLandmarks;

            if (gameState === 'playing') {
                drawGameUI();
                if (hands && hands.length > 0) {
                    hands.forEach(hand => {
                        const wristX = hand[0].x;
                        if (wristX > 0.5) handleHandInteraction(hand, 1); 
                        else handleHandInteraction(hand, 2);
                    });
                }
            } else { // Handles 'ready', 'roundOver', 'gameOver'
                if (gameState !== 'ready') drawGameUI(); // Draw background elements during overlays
                drawOverlay();
                if (gameState === 'ready' && hands && hands.length === 2) startRound();
                if (gameState === 'gameOver' && hands && hands.length === 2) resetGame();
            }
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 1280, height: 720
        });
        camera.start().then(() => {
            loadingElement.style.display = 'none';
            resetGame(); // Immediately set the game state to 'ready'
        });
    </script>
</body>
</html>




